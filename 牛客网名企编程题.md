## 牛客网名企编程题刷题记录

### 动态规划

#### 连续最大和

空间复杂度O(N)解法

```c++
class Solution {
public:
    int FindGreatestSumOfSubArray(vector<int> array) {
        int size = array.size();
        vector<int> dp(size+1,1);
        dp[0] = array[0];
        int maxn=dp[0];
        for(int i = 1;i < size;i++)
        {
            dp[i] = max(array[i],dp[i-1]+array[i]);
            maxn = max(maxn,dp[i]);
        }
        return maxn;
    }
};
```

空间复杂度O(1)解法

```c++
class Solution {
public:
    int FindGreatestSumOfSubArray(vector<int> array) {
        int size = array.size();
        vector<int> dp(size+1,1);
        int tmp = 0;
        int maxn = array[0];
        for(int i=0;i<size;i++)
        {
            if(tmp + array[i] < 0)
            {
                tmp = 0;
            }
            else
            {
                tmp+= array[i];
            }
            maxn = max(maxn,tmp);
        }
        if(tmp!=0)
            return maxn;
        //否则说明数组都是负数
        return *max_element(array.begin(), array.end());
    }
};
```

#### 年终奖

```c++
class Bonus {
public:
    int getMost(vector<vector<int> > board) {
        // write code here
        int row = board.size();
        int col = board[0].size();
        int dp[row+1][col+1];
        dp[0][0] = board[0][0];
        for(int j=1;j<col;j++){
            dp[0][j] = dp[0][j-1] + board[0][j];
        }
        for(int i=1;i<row;i++){
            dp[i][0] = dp[i-1][0] + board[i][0];
        }
        for(int i=1;i<row;i++){
            for(int j=1;j<col;j++){
                dp[i][j] = max(dp[i-1][j],dp[i][j-1]) + board[i][j];
            }
            
        }
        return dp[row-1][col-1];
    }
};
```

#### 万万没想到之抓捕孔联顺

```c++
#include<bits/stdc++.h>
using namespace std;
int N,D;
const int maxn = 1e6+10
    ;
const long long mod = 99997867;
long long dp[maxn];
long long C(long long n){
    return n*(n-1)/2;
}
int main()
{
    cin>>N>>D;
    int a[maxn];
    long long cnt=0;
    for(int begin=0,end=0;end<N;end++){//固定起点
        cin>>a[end];
        while(end>=2&&a[end]-a[begin]>D){
            begin++;
        }
        cnt+=C(end-begin);
    }
    cout<<cnt%mod<<endl;
    return 0;
}
```

#### 股票交易日

```c++
class Stock {
public:
    int profit(vector<int> prices,int L,int R){
        int buy=prices[L];
        int maxPro = 0;
        for(int i=L+1;i<=R;i++){
            maxPro=max(maxPro,prices[i] - buy);
            buy=min(buy,prices[i]);
        }
        return maxPro;
    }
    int maxProfit(vector<int> prices, int n) {
         if(n == 1) return 0;
        int maxAns = 0;
        for(int i=1;i<n;i++){
            int temp=profit(prices,0,i);
            if(i+1<n)
                temp+=profit(prices,i+1,n-1);
            maxAns = max(maxAns,temp);
        }
        return maxAns;
    }
};
```

#### 最长公共子串

```c++
 class Solution {
    /**
     * longest common substring
     * @param str1 string字符串 the string
     * @param str2 string字符串 the string
     * @return string字符串
     */
    public:
    string LCS(string str1, string str2) {
        int size1 = str1.size();
        int size2 = str2.size();
        int maxLength = 0;
        int maxLastIndex = 0;//记录最长公共子串最后一个元素在字符串str1中的位置
        int dp[size2+1];
        for(int i=0;i<size1;i++){
            for(int j=size2;j>=0;j--){
                if(str1[i] == str2[j]){
                    dp[j+1] = dp[j]+1;
                    if(dp[j+1] > maxLength){
                        maxLength = dp[j+1];
                        maxLastIndex = i;
                    }
                }else{
                    dp[j+1] = 0;
                }
            }
        }
       return str1.substr(maxLastIndex - maxLength + 1, maxLastIndex);
     }
};
```

#### 最长回文子串（N^2时间复杂度）

```c++
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param A string字符串 
     * @return int整型
     */
    int getLongestPalindrome(string A) {
          int n=A.size();
        vector<vector<int>> dp(n,vector<int>(n));
        int ans = 1;
        for(int L=0;L<n;L++)
        {
            for(int i=0;i+L<n;i++)
            {
                int j=i+L;
                if(L==0)
                    dp[i][j] = 1;//只有一个元素
                else if(L==1)
                    dp[i][j] = (A[i] == A[j]);//只有两个元素
                else
                    dp[i][j] = (dp[i+1][j-1]) && (A[i]==A[j]);
                if(dp[i][j])
                    ans= max(ans,L+1);
            }
        }
        return ans;
    }
};
```

#### 最长上升子序列（一）

时间复杂度 N＾２

```c++
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 给定数组的最长严格上升子序列的长度。
     * @param arr int整型vector 给定的数组
     * @return int整型
     */
    int LIS(vector<int>& arr) {
         int size = arr.size();
          vector<int> dp(size+1,1);//以i为终点的最长上升子序列的长度
        int ans=0;
          for(int i=0;i<size;i++)
          {
              for(int j=0;j<i;j++)
              {
                  if(arr[i] > arr[j])
                      dp[i] = max(dp[j]+1,dp[i]);
                  ans = max(ans,dp[i]);
              }
          }
        return ans;
    }
};
```

#### 最长上升子序列（二）（WA代码）（ＮｌｏｇＮ时间复杂度）

二分＋贪心　

```c++
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 该数组最长严格上升子序列的长度
     * @param a int整型vector 给定的数组
     * @return int整型
     */
//     int binarySearch(vector<int> &arr,int R,int x)
//     {
//         int L=0,mid;
//         while(L <= R)
//         {
//             mid = (L+R)>>1;
//             if(arr[mid] <= x)
//                 L=mid+1;
//             else
//                 R=mid-1;
//         }
//         return L;
//     }
    
    int LIS(vector<int>& a) {
        int inf = 1e9+1;
        int size = a.size();
         vector<int> minLastElementOfLIS(size+1,inf);
        if(size==0)
            return 0;
        int ans = 1;
        minLastElementOfLIS[1] = a[0];
        for(int i=1;i<size;i++)
        {
            if(a[i] > minLastElementOfLIS[ans])
                minLastElementOfLIS[++ans] = a[i];
            else
                minLastElementOfLIS[lower_bound(minLastElementOfLIS.begin(),
                minLastElementOfLIS.end(),a[i])-minLastElementOfLIS.begin()]=a[i];
        }
        return ans;
    }
};
```

#### 最长公共子序列

```c++
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * s1和s2最长公共子序列的长度
     * @param s1 string字符串 
     * @param s2 string字符串 
     * @return int整型
     */
    int LCS(string s1, string s2) {
        int size1=s1.size(), size2=s2.size();
        int dp[size1+2][size2+2];
        memset(dp,0,sizeof(dp));
        for(int i=1;i<=size1;i++)
        {
            for(int j=1;j<=size2;j++)
            {
                if(s1[i-1] == s2[j-1])
                    dp[i][j]=dp[i-1][j-1] + 1;
                else
                {
                    dp[i][j]=max(dp[i-1][j],dp[i][j-1]);
                }
            }
        }
        return dp[size1][size2];
    }
};
```

#### 【模板】01背包

朴素01背包

```c++
#include<bits/stdc++.h>
using namespace std;
int V,n;
int v[1010],w[1010];
int dp[1010][1010];
int main()
{
    cin>>n>>V;
    for(int i=1;i<=n;i++)
    {
        cin>>v[i]>>w[i];
    }
    memset(dp,0,sizeof(dp));
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=V;j++)
        {
            if(j-v[i]>=0)
                dp[i][j]= max( dp[i-1][j],dp[i-1][j-v[i]]+w[i]);
            else
                dp[i][j]=dp[i-1][j];
        }
    }
    cout<<dp[n][V]<<endl;
    
    return 0;
}
```

滚动数组优化01背包

```c++
#include<bits/stdc++.h>
using namespace std;
int V,n;
int v[1010],w[1010];
int dp[1010];
int main()
{
    cin>>n>>V;
    for(int i=1;i<=n;i++)
    {
        cin>>v[i]>>w[i];
    }
    memset(dp,0,sizeof(dp));
    for(int i=1;i<=n;i++)
    {
        for(int j=V;j>=1;j--)
        {
            if(j>=v[i])
                dp[j]=max(dp[j],dp[j-v[i]]+w[i]);
        }
    }//滚动数组优化
    cout<<dp[V]<<endl;
    dp[0] = 0;
    for(int i=1;i<=V;i++)
        dp[i] = -0x7f7f7f;
    for(int i=1;i<=n;i++)
    {
        for(int j=V;j>=1;j--)
        {
            if(j>=v[i])
                dp[j] = max(dp[j],dp[j-v[i]] + w[i]);
        }
    }
    if(dp[V]<0)
        cout<<"0"<<endl;
    else 
        cout<<dp[V]<<endl;
    return 0;

```

#### 【模板】完全背包

完全背包朴素模板

```c++
#include<bits/stdc++.h>
using namespace std;
int V,n;
int v[1010],w[1010];
int main()
{
    cin>>n>>V;
    for(int i=1;i<=n;i++)
    {
        cin>>v[i]>>w[i];
    }
    int dp[1010][1010];
    memset(dp,0,sizeof(dp));
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=V;j++)
        {
            dp[i][j] = dp[i-1][j];
            for(int k=0;j >= k*v[i];k++)
            {
                dp[i][j] = max(dp[i][j],dp[i][j-k*v[i]] + k*w[i]);
            }
        }
    }
    cout<<dp[n][V]<<endl;
    return 0;
}
```

滚动数组优化完全背包

```c++
#include<bits/stdc++.h>
using namespace std;
int V,n;
int v[1010],w[1010];
int main()
{
    cin>>n>>V;
    for(int i=1;i<=n;i++)
    {
        cin>>v[i]>>w[i];
    }
    int dp[1010];
    memset(dp,0,sizeof(dp));
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=V;j++)
        {
            if(j >= v[i])
                 dp[j] = max(dp[j],dp[j-v[i]] + w[i]);
        }
    }
    cout<<dp[V]<<endl;
    
    dp[0] = 0;
    for(int i=1;i<=V;i++)
        dp[i] = -0x7f7f7f;
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=V;j++)
        {
            if(j >= v[i])
                 dp[j] = max(dp[j],dp[j-v[i]] + w[i]);
        }
    }
    if(dp[V] < 0)
        cout<<"0"<<endl;
    else
        cout<<dp[V]<<endl;
    return 0;
}
```

#### 涂色PAINT(环形区间DP)

```c++
#include<iostream>
#include<algorithm>
#include<stdio.h>
#include<cstring>
using namespace std;
#define mem(a, x) memset(a, x, sizeof(a))
typedef long long ll;
const int inf=0x3f3f3f3f;
string a;
int dp[110][110];
int main()
{
    cin>>a;
    mem(dp,0x3f3f3f);
    int n = a.size();
    a = ' ' + a;
    for(int i = 1;i <= n;i++){
        for(int j = 1;j + i - 1 <= n;j++){//枚举左端点
            int r = j + i - 1;//k为右端点
            if(r == j){
                dp[j][r] = 1;
                continue;
            }
            if(a[j] == a[r]) dp[j][r] = min(dp[j+1][r],dp[j][r-1]);
            else{
                for(int k = 1;k < r;k++){//枚举断点
                    dp[j][r] = min(dp[j][k]+dp[k+1][r],dp[j][r]);
                }
            }
        }
    }
    cout<<dp[1][n]<<endl;

}
```



### 图论

#### 带权的 DAG结点排序 （拓朴排序变式）

```c++
#include<bits/stdc++.h>
using namespace std;
int n,e;
struct Weight{
    int w,num;
};
vector<Weight> weight(n+1);
bool operator<(Weight a,Weight b){
    return a.w >= b.w;
}
priority_queue<int> Q;
int main()
{
    cin>>n>>e;

    for(int i=1;i<=n;i++){
        int seq,w;
        cin>>seq>>w;
        weight[seq].w=w;
        weight[seq].num=seq;
    }
    int u,v;
    vector<vector<int>> G(n+1);
    vector<int> in(n+1,0);
    for(int i=1;i<=n;i++){
        cin>>u>>v;
        G[u].push_back(v);
        in[v]++;
    }

    for(int u=1;u<=n;u++)
        if(!in[u])
            Q.push(u);
    while(!Q.empty()){
        int tmp=Q.top();
        cout<<tmp<<" ";
        Q.pop();
        for(int i=0;i<G[tmp].size();i++){
            in[G[tmp][i]]--;
            if(!in[G[tmp][i]])  Q.push(G[tmp][i]);
        }
    }
    return 0;
}
```

#### 潜在风险客户识别（WA代码）

```c++
#include<bits/stdc++.h>
using namespace std;
int n,m;

int flag[10010];//0为有风险
vector<int> G[10010];
int in[10010];
int vis[10010];

int dfs(int now,int safe)//safe为0是有风险
{
    vis[now]=1;
    if(!safe)
        flag[now] = 0;
    for(int i=0;i<G[now].size();i++)
    {
        int  v = G[now][i];
        if(vis[v] || flag[v]==0)
        {
            flag[now]=0;
            return 0;
        }
        if(dfs(v,1)==0)
            flag[now] = 0;
        if(flag[now] == 0){
            return 0;
        }
      }
    return 1;
}

int main()
{
    cin>>n>>m;
    memset(in,0,sizeof(in));
    memset(flag,-1,sizeof(flag));
    for(int i=1;i<=m;i++){
        int u,v;
        char c;
        cin>>u>>c>>v;
        G[u].push_back(v);
        in[v]++;
    }
    for(int i=1;i<=n;i++)
    {
        if(!in[i])
        {
            memset(vis,0,sizeof(vis));
            if(!dfs(i,1))
                flag[i] = 0;   
        }
    }
    int No=1;
    for(int i=1;i<=n;i++)
    {
        if(flag[i]!=0){
            cout<<i<<" ";
            No=0;
        }
    }
    if(No) cout<<"None"<<endl;
    return 0;
}
```

```c++
 /*
  1.以邻接矩阵的方式存储数据；
  2.没有出边的元素一定表示安全客户；
  3.找到没有出边的元素（弧头）后，保存该元素，再将邻接矩阵中包含该弧头的对应的边置零；
  4.检查邻接矩阵有没有变化（flag的作用），有变化则重复3，无变化则得到结果。
*/
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;
int D[10001][10001] = { 0 };
int out[10010]={0};
bool judge(int indx, int n)//判断某点是否有出边,有则返回false
{
	for (int k = 1; k < n + 1; k++)
		if (D[indx][k] == 1)
			return false;
	return true;
}
int main()
{
	int n,m;
	cin >> n>>m;
	for (int i = 0; i < m; i++)
	{
		int a, b;
		char c;
		cin >> a >>c >> b;
		D[a][b] = 1;
	}
	vector<int> result;
	while (1)
	{
		bool flag = 0;
		for (int i = 1; i <= n; i++)
		{
			if (judge(i,n) && find(result.begin(),result.end(),i)== result.end())
			{
				flag = 1;
				result.push_back(i);
				for (int k = 1; k <= n; k++)
					if (D[k][i] == 1)D[k][i] = 0;
			}
		}
		if (!flag)break;
	}
	int s = result.size();
	if (s == 0)
		cout << "None" << endl;
	else
	{
		sort(result.begin(), result.end());
		for (int i = 0; i < s - 1; i++)
		{
			cout << result[i] << " ";
		}
		cout << result[s - 1];
	}
	return 0;
}
```

#### 几个岛(dfs)

```c++
#include<bits/stdc++.h>
using namespace std;

int m,n,k;
int mp[10010][10010]={0};
int mpCopy[10010][10010];
vector<int> ans;
int dir[4][2]={{1,0},{-1,0},{0,1},{0,-1}};

void dfs(int x,int y)
{
    mpCopy[x][y] = 0;
    for(int k=0;k<4;k++)
    {
        int ux = x+dir[k][0];
        int uy = y+dir[k][1];
        if(mpCopy[ux][uy]==0 || ux<0 || ux>=m||uy<0||uy>=n)
            continue;
        dfs(ux,uy);
    }
}

int count()
{
    for(int i=0;i<m;i++)
        for(int j=0;j<n;j++)
            mpCopy[i][j] = mp[i][j];
    int cnt = 0;
    for(int i=0;i<m;i++)
        for(int j=0;j<n;j++)
        {
            if(mpCopy[i][j] == 1)
               dfs(i,j) , cnt++;
        }
    return cnt;
}

int main()
{
    cin>>m>>n>>k;
    for(int i=1;i<=k;i++)
    {
        int row,col;
        cin>>row>>col;
        if(row<m&&row>=0 && col>=0&&col<n)
            mp[row][col] = 1;
        int temp = count();
        ans.push_back(temp);
    }
    for(int i=0;i<ans.size();i++)
        cout<<ans[i]<<" ";
    cout<<endl;
    return 0;
}
```

#### 派分糖果（拓朴排序做法）(WA 代码)

```c++
#include<bits/stdc++.h>
using namespace std;

vector<int> row;

int n;
int toposort(vector<int>G[],int out[],int Num[])
{
    int ans=0;
    queue<int> q;
    for(int i=0;i<n;i++)
    {
        if(out[i] == 0)
            Num[i]=1, q.push(i);
    }
    while(!q.empty())
    {
        int u = q.front();
        ans+=u;
        q.pop();
        for(int i=0;i<G[u].size();i++)
        {
            int v=G[u][i];
            out[v]--;
            if(out[v] == 0)
            {
                q.push(v);
                Num[v] = Num[u]+1;
            }
        }
    }
    return ans;
}

int main()
{
    int num;
    while(cin>>num)
    {
        row.push_back(num);
    }
    n = row.size();
    vector<int> G[n+1];
    int out[n+1];
    int Num[n+1];
    memset(out,0,sizeof(out));
    memset(Num,0,sizeof(Num));
    for(int i=0;i<n-1;i++){
        int u,v;
        if(row[i] > row[i+1])
            u = i,v=i+1;
        if(row[i] < row[i+1])
            u = i+1,v=i;
        if(row[i] == row[i+1])
            continue;
        G[v].push_back(u);
        out[u]++;
    }
    cout<<toposort(G,out,Num)<<endl;
    return 0;
}
```



### 树

#### 实现二叉树的前中后序遍历

```c++
/**
 * struct TreeNode {
 *	int val;
 *	struct TreeNode *left;
 *	struct TreeNode *right;
 * };
 */

class Solution {
public:
    /**
     * 
     * @param root TreeNode类 the root of binary tree
     * @return int整型vector<vector<>>
     */
    vector<int> pre;
    vector<int> in;
    vector<int> post;
    void preOrder(TreeNode * root){
        pre.push_back(root->val);
        if(root->left)
            preOrder(root->left);
        if(root->right)
            preOrder(root->right);
    }
    void inOrder(TreeNode * root){
        if(root->left)
            inOrder(root->left);
        in.push_back(root->val);
        if(root->right)
            inOrder(root->right);
    }
    void postOrder(TreeNode * root){
        if(root->left)
            postOrder(root->left);
        if(root->right)
            postOrder(root->right);
        post.push_back(root->val);
    }
    vector<vector<int> > threeOrders(TreeNode* root) {
        // write code here
        vector<vector<int>> ans;
        if(root == NULL){
            ans.push_back(pre);
            ans.push_back(in);
            ans.push_back(post);
            return ans;
        }
        preOrder(root);
        inOrder(root);
        postOrder(root);
        ans.push_back(pre);
        ans.push_back(in);
        ans.push_back(post);
        return ans;
    }
};
```

#### 二叉树根节点到叶子节点的所有路径和

```c++
/**
 * struct TreeNode {
 *	int val;
 *	struct TreeNode *left;
 *	struct TreeNode *right;
 * };
 */

class Solution {
public:
    /**
     * 
     * @param root TreeNode类 
     * @return int整型
     */
    int sum = 0;
   vector<int> step;
    void compute(){
        int size = step.size();
        int tempSum = 0;
        vector<int>::iterator it = step.end()-1;
        for(int i=0;i<size;i++){
            tempSum += *it * pow(10,i);
            it--;
        }
        sum += tempSum;
    }
    void dfs(TreeNode * root){
        step.push_back(root->val);
        if(root->left==NULL && root->right==NULL){
            compute();
            step.erase(step.end()-1);
            return;
        }
        if(root->left)
            dfs(root->left);
        if(root->right)
            dfs(root->right);
        step.erase(step.end()-1);
    }
    int sumNumbers(TreeNode* root) {
        if(!root)
            return 0;
        dfs(root);
        return sum;
    }
};
```

时间复杂度为O (N) 空间复杂度为O(1)的标准解法

```c++
/**
 * struct TreeNode {
 *    struct TreeNode *right;
 * };
 */
 
class Solution {
public:
    /**
     *
     * @param root TreeNode类
     * @return int整型
     */
    int sumNumbers(TreeNode* root) {
        // write code here
        if(!root)//特殊情况
            return 0;
        int sum = 0;
        return preorder(root, sum);
    }
    
    int preorder(TreeNode* root, int sum){
        if(root == NULL)
            return 0;
        sum = sum * 10 + root->val;//一层一层进行遍历
        if(!root->left && !root->right)//没有子结点
            return sum;
        return preorder(root->left, sum) + preorder(root->right, sum);
    }
};
```

#### 输出二叉树的右视图

```c++
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     * 求二叉树的右视图
     * @param xianxu int整型vector 先序遍历
     * @param zhongxu int整型vector 中序遍历
     * @return int整型vector
     */
    unordered_map<int, int> index;
    TreeNode * buildTree(vector<int>& xianxu,int l1,int r1,vector<int>zhongxu,int l2,int r2)
    {
        if(l1>r1 || l2>r2)
            return NULL;
        int xianxu_root=l1;//前序遍历中的第一个结点就是根节点
        int zhongxu_root=index[xianxu[xianxu_root]];//中序遍历中定位根节点
        TreeNode * root=new TreeNode(xianxu[xianxu_root]);
        int leftsize=zhongxu_root-l2;
        root->left=buildTree(xianxu,l1+1,l1+leftsize,zhongxu,l2,zhongxu_root-1);
        root->right=buildTree(xianxu,l1+leftsize+1,r1,zhongxu,zhongxu_root+1,r2);
        return root;
    }
    
    vector<int> rightSideView(TreeNode * root){
        vector<int> res;
        queue<TreeNode*> Q;
        Q.push(root);
        while(!Q.empty())
        {
            int size = Q.size();
            //队列中的大小即是这一层的节点数
            while(size--)
            {
                TreeNode * temp = Q.front();
                Q.pop();
                if(temp->left)
                    Q.push(temp->left);
                if(temp->right)
                    Q.push(temp->right);
                if(size==0)//最右元素
                    res.push_back(temp->val);
            }
        }
        return res;
    }
    
    vector<int> solve(vector<int>& xianxu, vector<int>& zhongxu) {
        // write code here
        vector<int> res;
        if(xianxu.size()==0)
            return res;
        for(int i=0;i<xianxu.size();i++){
            index[zhongxu[i]] = i;
        }
        TreeNode * root=buildTree(xianxu,0,xianxu.size()-1,zhongxu,0,zhongxu.size()-1);
        return rightSideView(root);
    }
};
```

#### 二叉树第k个节点

```c++
/**
 * struct TreeNode {
 *	int val;
 *	struct TreeNode *left;
 *	struct TreeNode *right;
 *	TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 * };
 */
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param proot TreeNode类 
     * @param k int整型 
     * @return int整型
     */
    vector<int> in;
    void inOrder(TreeNode * root)
    {
        if(root->left)
            inOrder(root->left);
        in.push_back(root->val);
        if(root->right)
            inOrder(root->right);
    }
    int KthNode(TreeNode* proot, int k) {
        // write code here
        if(proot == NULL) return -1;
        inOrder(proot);
        if(k>in.size() || k<=0)
            return -1;
        return in[k-1];
    }
};
```

#### 判断t1树中是否含有和t2树一样的子树(WA代码)

```c++
/**
 * struct TreeNode {
 *	int val;
 *	struct TreeNode *left;
 *	struct TreeNode *right;
 * };
 */

class Solution {
public:
    /**
     * 
     * @param root1 TreeNode类 
     * @param root2 TreeNode类 
     * @return bool布尔型
     */
    bool flag=false;
    bool check(TreeNode* root1, TreeNode* root2){
        if(root1==NULL && root2==NULL)
            return false;
        if(root1->left==NULL && root2->left==NULL && root1->right==NULL && root2->right==NULL)
        {    
            flag=flag||(root1->val==root2->val);
            return root1->val==root2->val;
        }
        bool Left=false;
        bool Right=false;
        if(root1->left && root2->left)
            Left = isContains(root1->left, root2->left);
        if(root1->left==NULL && root2->left==NULL)
            Left=true;
        if(root1->right && root2->right)
           Right = isContains(root1->right,root2->right);
        if(root1->right==NULL && root2->right==NULL)
            Right=true;
        flag=(flag||(Left && Right));
        return Left && Right;
    }    
    bool isContains(TreeNode* root1, TreeNode* root2) {
        // write code here
        bool a=check(root1,root2);
        return flag;
    }
};
```

#### 判断t1树中是否含有和t2树一样的子树(正解)

```c++
/**
 * struct TreeNode {
 *	int val;
 *	struct TreeNode *left;
 *	struct TreeNode *right;
 * };
 */

class Solution {
public:
    /**
     *
     * @param root1 TreeNode类
     * @param root2 TreeNode类
     * @return bool布尔型
     */
    bool isContains(TreeNode* root1, TreeNode* root2) {
        // write code here
        if (root2 == NULL) return true;
        if (root1 == NULL) return false;
        return (isSubTree(root1, root2) || isContains(root1->left, root2) || isContains(root1->right, root2));
    }
 
    bool isSubTree(TreeNode* root1, TreeNode* root2) {
        if (root1 == NULL && root2 == NULL)
            return true;
        if (root1 == NULL || root2 == NULL || (root1->val != root2->val))
            return false;
        return (isSubTree(root1->left, root2->left) && isSubTree(root1->right, root2->right));
    }
 
};
```

