## 牛客网名企编程题刷题记录

[TOC]



### 动态规划

#### 连续最大和

空间复杂度O(N)解法

```c++
class Solution {
public:
    int FindGreatestSumOfSubArray(vector<int> array) {
        int size = array.size();
        vector<int> dp(size+1,1);
        dp[0] = array[0];
        int maxn=dp[0];
        for(int i = 1;i < size;i++)
        {
            dp[i] = max(array[i],dp[i-1]+array[i]);
            maxn = max(maxn,dp[i]);
        }
        return maxn;
    }
};
```

空间复杂度O(1)解法

```c++
class Solution {
public:
    int FindGreatestSumOfSubArray(vector<int> array) {
        int size = array.size();
        vector<int> dp(size+1,1);
        int tmp = 0;
        int maxn = array[0];
        for(int i=0;i<size;i++)
        {
            if(tmp + array[i] < 0)
            {
                tmp = 0;
            }
            else
            {
                tmp+= array[i];
            }
            maxn = max(maxn,tmp);
        }
        if(tmp!=0)
            return maxn;
        //否则说明数组都是负数
        return *max_element(array.begin(), array.end());
    }
};
```

#### 年终奖

```c++
class Bonus {
public:
    int getMost(vector<vector<int> > board) {
        // write code here
        int row = board.size();
        int col = board[0].size();
        int dp[row+1][col+1];
        dp[0][0] = board[0][0];
        for(int j=1;j<col;j++){
            dp[0][j] = dp[0][j-1] + board[0][j];
        }
        for(int i=1;i<row;i++){
            dp[i][0] = dp[i-1][0] + board[i][0];
        }
        for(int i=1;i<row;i++){
            for(int j=1;j<col;j++){
                dp[i][j] = max(dp[i-1][j],dp[i][j-1]) + board[i][j];
            }
            
        }
        return dp[row-1][col-1];
    }
};
```

#### 万万没想到之抓捕孔联顺

```c++
#include<bits/stdc++.h>
using namespace std;
int N,D;
const int maxn = 1e6+10
    ;
const long long mod = 99997867;
long long dp[maxn];
long long C(long long n){
    return n*(n-1)/2;
}
int main()
{
    cin>>N>>D;
    int a[maxn];
    long long cnt=0;
    for(int begin=0,end=0;end<N;end++){//固定起点
        cin>>a[end];
        while(end>=2&&a[end]-a[begin]>D){
            begin++;
        }
        cnt+=C(end-begin);
    }
    cout<<cnt%mod<<endl;
    return 0;
}
```

#### 股票交易日

```c++
class Stock {
public:
    int profit(vector<int> prices,int L,int R){
        int buy=prices[L];
        int maxPro = 0;
        for(int i=L+1;i<=R;i++){
            maxPro=max(maxPro,prices[i] - buy);
            buy=min(buy,prices[i]);
        }
        return maxPro;
    }
    int maxProfit(vector<int> prices, int n) {
         if(n == 1) return 0;
        int maxAns = 0;
        for(int i=1;i<n;i++){
            int temp=profit(prices,0,i);
            if(i+1<n)
                temp+=profit(prices,i+1,n-1);
            maxAns = max(maxAns,temp);
        }
        return maxAns;
    }
};
```

#### 最长公共子串

```c++
 class Solution {
    /**
     * longest common substring
     * @param str1 string字符串 the string
     * @param str2 string字符串 the string
     * @return string字符串
     */
    public:
    string LCS(string str1, string str2) {
        int size1 = str1.size();
        int size2 = str2.size();
        int maxLength = 0;
        int maxLastIndex = 0;//记录最长公共子串最后一个元素在字符串str1中的位置
        int dp[size2+1];
        for(int i=0;i<size1;i++){
            for(int j=size2;j>=0;j--){
                if(str1[i] == str2[j]){
                    dp[j+1] = dp[j]+1;
                    if(dp[j+1] > maxLength){
                        maxLength = dp[j+1];
                        maxLastIndex = i;
                    }
                }else{
                    dp[j+1] = 0;
                }
            }
        }
       return str1.substr(maxLastIndex - maxLength + 1, maxLastIndex);
     }
};
```

#### 最长回文子串（N^2时间复杂度）

```c++
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param A string字符串 
     * @return int整型
     */
    int getLongestPalindrome(string A) {
          int n=A.size();
        vector<vector<int>> dp(n,vector<int>(n));
        int ans = 1;
        for(int L=0;L<n;L++)
        {
            for(int i=0;i+L<n;i++)
            {
                int j=i+L;
                if(L==0)
                    dp[i][j] = 1;//只有一个元素
                else if(L==1)
                    dp[i][j] = (A[i] == A[j]);//只有两个元素
                else
                    dp[i][j] = (dp[i+1][j-1]) && (A[i]==A[j]);
                if(dp[i][j])
                    ans= max(ans,L+1);
            }
        }
        return ans;
    }
};
```

#### 最长上升子序列（一）

时间复杂度 N＾２

```c++
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 给定数组的最长严格上升子序列的长度。
     * @param arr int整型vector 给定的数组
     * @return int整型
     */
    int LIS(vector<int>& arr) {
         int size = arr.size();
          vector<int> dp(size+1,1);//以i为终点的最长上升子序列的长度
        int ans=0;
          for(int i=0;i<size;i++)
          {
              for(int j=0;j<i;j++)
              {
                  if(arr[i] > arr[j])
                      dp[i] = max(dp[j]+1,dp[i]);
                  ans = max(ans,dp[i]);
              }
          }
        return ans;
    }
};
```

#### 最长上升子序列（二）（WA代码）（ＮｌｏｇＮ时间复杂度）

二分＋贪心　

```c++
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 该数组最长严格上升子序列的长度
     * @param a int整型vector 给定的数组
     * @return int整型
     */
//     int binarySearch(vector<int> &arr,int R,int x)
//     {
//         int L=0,mid;
//         while(L <= R)
//         {
//             mid = (L+R)>>1;
//             if(arr[mid] <= x)
//                 L=mid+1;
//             else
//                 R=mid-1;
//         }
//         return L;
//     }
    
    int LIS(vector<int>& a) {
        int inf = 1e9+1;
        int size = a.size();
         vector<int> minLastElementOfLIS(size+1,inf);
        if(size==0)
            return 0;
        int ans = 1;
        minLastElementOfLIS[1] = a[0];
        for(int i=1;i<size;i++)
        {
            if(a[i] > minLastElementOfLIS[ans])
                minLastElementOfLIS[++ans] = a[i];
            else
                minLastElementOfLIS[lower_bound(minLastElementOfLIS.begin(),
                minLastElementOfLIS.end(),a[i])-minLastElementOfLIS.begin()]=a[i];
        }
        return ans;
    }
};
```

#### 最长公共子序列

```c++
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * s1和s2最长公共子序列的长度
     * @param s1 string字符串 
     * @param s2 string字符串 
     * @return int整型
     */
    int LCS(string s1, string s2) {
        int size1=s1.size(), size2=s2.size();
        int dp[size1+2][size2+2];
        memset(dp,0,sizeof(dp));
        for(int i=1;i<=size1;i++)
        {
            for(int j=1;j<=size2;j++)
            {
                if(s1[i-1] == s2[j-1])
                    dp[i][j]=dp[i-1][j-1] + 1;
                else
                {
                    dp[i][j]=max(dp[i-1][j],dp[i][j-1]);
                }
            }
        }
        return dp[size1][size2];
    }
};
```

#### 【模板】01背包

朴素01背包

```c++
#include<bits/stdc++.h>
using namespace std;
int V,n;
int v[1010],w[1010];
int dp[1010][1010];
int main()
{
    cin>>n>>V;
    for(int i=1;i<=n;i++)
    {
        cin>>v[i]>>w[i];
    }
    memset(dp,0,sizeof(dp));
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=V;j++)
        {
            if(j-v[i]>=0)
                dp[i][j]= max( dp[i-1][j],dp[i-1][j-v[i]]+w[i]);
            else
                dp[i][j]=dp[i-1][j];
        }
    }
    cout<<dp[n][V]<<endl;
    
    return 0;
}
```

滚动数组优化01背包

```c++
#include<bits/stdc++.h>
using namespace std;
int V,n;
int v[1010],w[1010];
int dp[1010];
int main()
{
    cin>>n>>V;
    for(int i=1;i<=n;i++)
    {
        cin>>v[i]>>w[i];
    }
    memset(dp,0,sizeof(dp));
    for(int i=1;i<=n;i++)
    {
        for(int j=V;j>=1;j--)
        {
            if(j>=v[i])
                dp[j]=max(dp[j],dp[j-v[i]]+w[i]);
        }
    }//滚动数组优化
    cout<<dp[V]<<endl;
    dp[0] = 0;
    for(int i=1;i<=V;i++)
        dp[i] = -0x7f7f7f;
    for(int i=1;i<=n;i++)
    {
        for(int j=V;j>=1;j--)
        {
            if(j>=v[i])
                dp[j] = max(dp[j],dp[j-v[i]] + w[i]);
        }
    }
    if(dp[V]<0)
        cout<<"0"<<endl;
    else 
        cout<<dp[V]<<endl;
    return 0;

```

#### 【模板】完全背包

完全背包朴素模板

```c++
#include<bits/stdc++.h>
using namespace std;
int V,n;
int v[1010],w[1010];
int main()
{
    cin>>n>>V;
    for(int i=1;i<=n;i++)
    {
        cin>>v[i]>>w[i];
    }
    int dp[1010][1010];
    memset(dp,0,sizeof(dp));
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=V;j++)
        {
            dp[i][j] = dp[i-1][j];
            for(int k=0;j >= k*v[i];k++)
            {
                dp[i][j] = max(dp[i][j],dp[i][j-k*v[i]] + k*w[i]);
            }
        }
    }
    cout<<dp[n][V]<<endl;
    return 0;
}
```

滚动数组优化完全背包

```c++
#include<bits/stdc++.h>
using namespace std;
int V,n;
int v[1010],w[1010];
int main()
{
    cin>>n>>V;
    for(int i=1;i<=n;i++)
    {
        cin>>v[i]>>w[i];
    }
    int dp[1010];
    memset(dp,0,sizeof(dp));
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=V;j++)
        {
            if(j >= v[i])
                 dp[j] = max(dp[j],dp[j-v[i]] + w[i]);
        }
    }
    cout<<dp[V]<<endl;
    
    dp[0] = 0;
    for(int i=1;i<=V;i++)
        dp[i] = -0x7f7f7f;
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=V;j++)
        {
            if(j >= v[i])
                 dp[j] = max(dp[j],dp[j-v[i]] + w[i]);
        }
    }
    if(dp[V] < 0)
        cout<<"0"<<endl;
    else
        cout<<dp[V]<<endl;
    return 0;
}
```

#### 涂色PAINT(环形区间DP)

```c++
#include<iostream>
#include<algorithm>
#include<stdio.h>
#include<cstring>
using namespace std;
#define mem(a, x) memset(a, x, sizeof(a))
typedef long long ll;
const int inf=0x3f3f3f3f;
string a;
int dp[110][110];
int main()
{
    cin>>a;
    mem(dp,0x3f3f3f);
    int n = a.size();
    a = ' ' + a;
    for(int i = 1;i <= n;i++){
        for(int j = 1;j + i - 1 <= n;j++){//枚举左端点
            int r = j + i - 1;//k为右端点
            if(r == j){
                dp[j][r] = 1;
                continue;
            }
            if(a[j] == a[r]) dp[j][r] = min(dp[j+1][r],dp[j][r-1]);
            else{
                for(int k = 1;k < r;k++){//枚举断点
                    dp[j][r] = min(dp[j][k]+dp[k+1][r],dp[j][r]);
                }
            }
        }
    }
    cout<<dp[1][n]<<endl;

}
```



### 图论

#### 带权的 DAG结点排序 （拓朴排序变式）

```c++
#include<bits/stdc++.h>
using namespace std;
int n,e;
struct Weight{
    int w,num;
};
vector<Weight> weight(n+1);
bool operator<(Weight a,Weight b){
    return a.w >= b.w;
}
priority_queue<int> Q;
int main()
{
    cin>>n>>e;

    for(int i=1;i<=n;i++){
        int seq,w;
        cin>>seq>>w;
        weight[seq].w=w;
        weight[seq].num=seq;
    }
    int u,v;
    vector<vector<int>> G(n+1);
    vector<int> in(n+1,0);
    for(int i=1;i<=n;i++){
        cin>>u>>v;
        G[u].push_back(v);
        in[v]++;
    }

    for(int u=1;u<=n;u++)
        if(!in[u])
            Q.push(u);
    while(!Q.empty()){
        int tmp=Q.top();
        cout<<tmp<<" ";
        Q.pop();
        for(int i=0;i<G[tmp].size();i++){
            in[G[tmp][i]]--;
            if(!in[G[tmp][i]])  Q.push(G[tmp][i]);
        }
    }
    return 0;
}
```

#### 潜在风险客户识别（WA代码）

```c++
#include<bits/stdc++.h>
using namespace std;
int n,m;

int flag[10010];//0为有风险
vector<int> G[10010];
int in[10010];
int vis[10010];

int dfs(int now,int safe)//safe为0是有风险
{
    vis[now]=1;
    if(!safe)
        flag[now] = 0;
    for(int i=0;i<G[now].size();i++)
    {
        int  v = G[now][i];
        if(vis[v] || flag[v]==0)
        {
            flag[now]=0;
            return 0;
        }
        if(dfs(v,1)==0)
            flag[now] = 0;
        if(flag[now] == 0){
            return 0;
        }
      }
    return 1;
}

int main()
{
    cin>>n>>m;
    memset(in,0,sizeof(in));
    memset(flag,-1,sizeof(flag));
    for(int i=1;i<=m;i++){
        int u,v;
        char c;
        cin>>u>>c>>v;
        G[u].push_back(v);
        in[v]++;
    }
    for(int i=1;i<=n;i++)
    {
        if(!in[i])
        {
            memset(vis,0,sizeof(vis));
            if(!dfs(i,1))
                flag[i] = 0;   
        }
    }
    int No=1;
    for(int i=1;i<=n;i++)
    {
        if(flag[i]!=0){
            cout<<i<<" ";
            No=0;
        }
    }
    if(No) cout<<"None"<<endl;
    return 0;
}
```

```c++
 /*
  1.以邻接矩阵的方式存储数据；
  2.没有出边的元素一定表示安全客户；
  3.找到没有出边的元素（弧头）后，保存该元素，再将邻接矩阵中包含该弧头的对应的边置零；
  4.检查邻接矩阵有没有变化（flag的作用），有变化则重复3，无变化则得到结果。
*/
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;
int D[10001][10001] = { 0 };
int out[10010]={0};
bool judge(int indx, int n)//判断某点是否有出边,有则返回false
{
	for (int k = 1; k < n + 1; k++)
		if (D[indx][k] == 1)
			return false;
	return true;
}
int main()
{
	int n,m;
	cin >> n>>m;
	for (int i = 0; i < m; i++)
	{
		int a, b;
		char c;
		cin >> a >>c >> b;
		D[a][b] = 1;
	}
	vector<int> result;
	while (1)
	{
		bool flag = 0;
		for (int i = 1; i <= n; i++)
		{
			if (judge(i,n) && find(result.begin(),result.end(),i)== result.end())
			{
				flag = 1;
				result.push_back(i);
				for (int k = 1; k <= n; k++)
					if (D[k][i] == 1)D[k][i] = 0;
			}
		}
		if (!flag)break;
	}
	int s = result.size();
	if (s == 0)
		cout << "None" << endl;
	else
	{
		sort(result.begin(), result.end());
		for (int i = 0; i < s - 1; i++)
		{
			cout << result[i] << " ";
		}
		cout << result[s - 1];
	}
	return 0;
}
```

#### 几个岛(dfs)

```c++
#include<bits/stdc++.h>
using namespace std;

int m,n,k;
int mp[10010][10010]={0};
int mpCopy[10010][10010];
vector<int> ans;
int dir[4][2]={{1,0},{-1,0},{0,1},{0,-1}};

void dfs(int x,int y)
{
    mpCopy[x][y] = 0;
    for(int k=0;k<4;k++)
    {
        int ux = x+dir[k][0];
        int uy = y+dir[k][1];
        if(mpCopy[ux][uy]==0 || ux<0 || ux>=m||uy<0||uy>=n)
            continue;
        dfs(ux,uy);
    }
}

int count()
{
    for(int i=0;i<m;i++)
        for(int j=0;j<n;j++)
            mpCopy[i][j] = mp[i][j];
    int cnt = 0;
    for(int i=0;i<m;i++)
        for(int j=0;j<n;j++)
        {
            if(mpCopy[i][j] == 1)
               dfs(i,j) , cnt++;
        }
    return cnt;
}

int main()
{
    cin>>m>>n>>k;
    for(int i=1;i<=k;i++)
    {
        int row,col;
        cin>>row>>col;
        if(row<m&&row>=0 && col>=0&&col<n)
            mp[row][col] = 1;
        int temp = count();
        ans.push_back(temp);
    }
    for(int i=0;i<ans.size();i++)
        cout<<ans[i]<<" ";
    cout<<endl;
    return 0;
}
```

#### 派分糖果（拓朴排序做法）(WA 代码)

```c++
#include<bits/stdc++.h>
using namespace std;

vector<int> row;

int n;
int toposort(vector<int>G[],int out[],int Num[])
{
    int ans=0;
    queue<int> q;
    for(int i=0;i<n;i++)
    {
        if(out[i] == 0)
            Num[i]=1, q.push(i);
    }
    while(!q.empty())
    {
        int u = q.front();
        ans+=u;
        q.pop();
        for(int i=0;i<G[u].size();i++)
        {
            int v=G[u][i];
            out[v]--;
            if(out[v] == 0)
            {
                q.push(v);
                Num[v] = Num[u]+1;
            }
        }
    }
    return ans;
}

int main()
{
    int num;
    while(cin>>num)
    {
        row.push_back(num);
    }
    n = row.size();
    vector<int> G[n+1];
    int out[n+1];
    int Num[n+1];
    memset(out,0,sizeof(out));
    memset(Num,0,sizeof(Num));
    for(int i=0;i<n-1;i++){
        int u,v;
        if(row[i] > row[i+1])
            u = i,v=i+1;
        if(row[i] < row[i+1])
            u = i+1,v=i;
        if(row[i] == row[i+1])
            continue;
        G[v].push_back(u);
        out[u]++;
    }
    cout<<toposort(G,out,Num)<<endl;
    return 0;
}
```

#### 小米Git（LCA）WA  

尚未解决无向表转化为有向表问题

```c++
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param matrix string字符串vector 
     * @param versionA int整型 
     * @param versionB int整型 
     * @return int整型
     */
    void FindAncestor(vector<int>father,int son,vector<int>& vis)
    {
        int now = son;
        while(1)
        {
            vis[now] = 1;
            if(father[now] == now)
                return;
            now = father[now];
        }
    }
    int LCA(vector<int>father,int now,vector<int>& vis)
    {
        while(1)
        {
            if(vis[now])
                return  now;
            now = father[now];
        }
    }
    int Git(vector<string>& matrix, int versionA, int versionB) {
        // write code here
        int size = matrix.size();
        vector<int> vis(size+1,0);
        vector<int> check(size+1,0);
        vector<int> father(size+1,-1);
        for(int i=0;i<size;i++)
            father[i]=i;
        for(int i=0;i<size;i++)
        {
            for(int j=0;j<size;j++)
            {
                if(i==j)
                    continue;
                if(matrix[i][j]=='1' && father[i]!=j && check[j]==0)
                {
                    father[j] = i;
                    check[i] = 1;
                    //check[i]=1;
                    //cout<<i<<" "<<j<<" "<<father[j]<<endl;
                }
            }
        }
//         for(int i=0;i<size;i++)
//             cout<<father[i]<<endl;
        FindAncestor(father, versionA, vis);
        int ans = LCA(father, versionB, vis);
            return ans;
    }
};
```

#### 卡中心美食家(拓扑排序)

```c++
#include<bits/stdc++.h>
using namespace std;
int n,m;

int main()
{
    cin>>n>>m;
    bool flag = true;
    vector<vector<int>> G(n);
    vector<int> in(n,0);
    for(int i=1;i<=m;i++)
    {
        int u,v;
        cin>>u>>v;
        G[v].push_back(u);
        in[u]++;
    }

    queue<int> Q;
    vector<int> tuopu;


    for(int i=0;i<n;i++)
    {
        if(in[i]==0)
        {
            Q.push(i);
            while(!Q.empty())
            {
                int node=Q.front();
                Q.pop();
                //cout<<node<<endl;
                tuopu.push_back(node);
                for(int j=0;j<G[node].size();j++)
                {
                    int tmp=G[node][j];
                    in[tmp]--;
                    if(in[tmp] == 0){
                        Q.push(tmp);
                        in[tmp] = -1;//将已经加入队列过的点入读置0 防止其在后面新的入口被访问到
                    }
                }
            }
        }
    }

    if(tuopu.size() != n) //判断是否是DAG
        flag = false;
    if(!flag){
        cout<<"None"<<endl;
        return 0;
    }
    for(int i = 0;i < n-1; i++)
        cout<<tuopu[i]<<",";
    cout<<tuopu[n-1];
    return 0;
}

```

#### 拼多多周年庆（WA代码）

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.TreeSet;

public class Main
{
    static  int m;
    static ArrayList<Integer> parents = new ArrayList<>();
    static ArrayList<HashSet<Integer>> children = new ArrayList<>();
    static ArrayList<Integer> dists = new ArrayList<>();
    public static void main(String arg[]) throws IOException //抛出异常
    {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in)) ;
        m = Integer.parseInt(br.readLine());
        int n = Integer.parseInt(br.readLine());
        for(int i=0;i<n;i++)
        {
            dists.add(0);
            parents.add(-1);
            children.add(new HashSet<>());
        }
        //建图
        for(int i=0;i<n-1;i++)
        {
            String [] str = br.readLine().split(" ");
            int u = Integer.parseInt(str[0]); int v = Integer.parseInt(str[1]);
            int d = Integer.parseInt(str[2]);
            if( d > m)
                continue;
            children.get(u).add(v);
            parents.set(v,u); //把ArrayList第v个元素设置为u
            dists.set(v,d);
        }
        //寻找树根
        int root = 0;
        while(parents.get(root) != -1)
        {
            root = parents.get(root);
        }
        System.out.println(dfs(root).last());
    }
    private static TreeSet<Integer> dfs(int root)
    {
        TreeSet<Integer> res = new TreeSet<>();
        int d = dists.get(root); //该节点的父节点到该节点的距离
        res.add(0);
        if(children.get(root).size() == 0)
        {
            res.add(d);
            return res;
        }
        //每个集合表示每个孩子结点可选的路径
        ArrayList<TreeSet<Integer>> sets = new ArrayList<>();
        for(int child:children.get(root))
            sets.add(dfs(child));
        for(int i=0;i<sets.size();i++)
        {
            //选中一个孩子分支的情况
            for(int path = 0;path < sets.get(i).size();path++)
            {
                if( d + path <= m)
                    res.add(d + path);
            }
            //选中两个孩子分支
            for(int j=i+1;j<sets.size();j++)
            {
                for(int path1:sets.get(i))
                {
                    for(int path2:sets.get(j))
                    {
                        if(path1+path2+d <= m)
                            res.add(path1 + path2 +d);
                    }
                }
            }
        }
        return res;
    }
}
```

#### 病毒传播（bfs层序遍历）

java 语言

```java
import java.util.*;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
public class Main
{
    static ArrayList<ArrayList<Integer>> G = new ArrayList<>();
    static int n,m;
    static int k,t;
    public static void main(String arg[])throws IOException
    {
        Scanner in = new Scanner(System.in);
        n = in.nextInt(); m = in.nextInt();
        for(int i=1;i<=n+1;i++)
        {
            ArrayList<Integer> arr = new ArrayList<>();
             G.add(arr);
        }
        //建图
        for(int i=0 ; i < m ; i++)
        {
            int u = in.nextInt();
            int v = in.nextInt();
            if( u != v)//去自环
            {
                G.get(u).add(v);
                G.get(v).add(u);
            }
        }
        k = in.nextInt();
        t = in.nextInt();
        HashSet infected = new HashSet();
        for(int i=1;i<=k;i++)
        {
             infected.add(in.nextInt());
        }
        
        ArrayList res = new ArrayList();
        for(int i=1;i<=n;i++)
        {
            if(bfs(infected,i))
            {
                res.add(i);
            }
        }
        if(res.size() == 0)
            System.out.println(-1);
        else
        {
            for(int i=0;i<res.size()-1;i++)
            {
                System.out.print(res.get(i));
                System.out.print(' ');
            }
            System.out.print(res.get(res.size()-1));
        }
    }
    
    private static boolean bfs(HashSet infected,int begin)
    {
        LinkedList<Integer> queue = new LinkedList<Integer>();
        HashSet vis = new HashSet();
         if(infected.contains(begin))
         {
              queue.addLast(begin);
              vis.add(begin);
         }
        int days = 0;
        while(!queue.isEmpty())
        {//层序遍历
             for(int i=0;i<queue.size();i++)
             {
                 Integer node = queue.removeFirst();
                 for(int j=0;j<G.get(node).size();j++)
                 {
                     int next = G.get(node).get(j);
                     if(!infected.contains(next))
                         return false;
                     else if(!vis.contains(next)){
                         vis.add(next);
                         queue.addLast(next);
                     }
                 }
             }
            if(++days == t)
                break;
        }
        return vis.size() == infected.size();
    }
}
```

#### 共享单车 (Dijkstra最短路)

```c++
#include<bits/stdc++.h>
using namespace std;
int n,m,k;
int inf = 0x7f7f7f;
struct edge
{
    int from,to,w;
    edge(int a,int b,int c)
    {
        from = a;to = b,w = c;
    }
};
vector<edge> G[100010];
struct node
{
    int id,dis;
    bool isbycicle;//进过该点时是否骑车
    node(int a,int b,bool c=false)
    {
        id = a;dis = b;
        isbycicle = c;
    }
};

bool operator<(node a,node b)
{
    return a.dis > b.dis;
}
int ans;

bool bycicle[100010];
void dijkstra()
{
    int s = 1;
    int dis[100010];
    bool done[100010];
    for(int i=1;i<=n;i++)
    {
        dis[i] = inf;
        done[i] = false;
    }
    priority_queue<node> Q;
    Q.push(node(s,dis[s]));
    while(!Q.empty())
    {
        node u = Q.top();
        Q.pop();
        if(done[u.id])
            continue;
        done[u.id] = true;
        if(bycicle[u.id])
            u.isbycicle = true;
            
        for(int i=0;i<G[u.id].size();i++)
        {
            edge y = G[u.id][i];
            if(done[y.to])
                continue;
            if(u.isbycicle)
            {
                if(dis[y.to] > dis[u.id] + y.w/2){
                    dis[y.to] = dis[u.id] + y.w/2;
                    Q.push(node(y.to,dis[y.to],true));
                }
            }
            else
            {
                if(dis[y.to] > dis[u.id] + y.w){
                    dis[y.to] = dis[u.id] + y.w;
                    Q.push(node(y.to,dis[y.to],false));
                }
            }    
        }
        
    }
    ans = dis[n];
}

int main()
{
    cin>>n>>m;
    for(int i=1;i<=m;i++)
        G[i].clear();
    for(int i=1;i<=n;i++)
        bycicle[i] = false;
    for(int i=1;i<=m;i++)
    {
        int u,v,w;
        cin>>u>>v>>w;
        G[u].push_back(edge(u,v,w));
        G[v].push_back(edge(v,u,w));
    }
    cin>>k;
    for(int i=1;i<=k;i++)
    {
        int a;
        cin>>a;
        bycicle[a]=true;
    }
    dijkstra();
    cout<<ans<<endl;
    return 0;
}
```

#### 公交车 （构建虚结点+Dijkstra最短路）

![image-20220323111451459](../../AppData/Roaming/Typora/typora-user-images/image-20220323111451459.png)

```c++
#include<bits/stdc++.h>
using namespace std;
int n,m;
int ans = 1;
vector<int> G[100010];
int inf = 0x7f7f7f;
struct node
{
    int id;int dis;
    node(int a,int b)
    {
        id=a;dis=b;
    }
};
bool operator<(node a,node b)
{
    return a.dis>b.dis;
}

void Disjktra()
{
    int s = 1;
    int dis[200010];
    bool done[200010];
    for(int i=1;i<=n+m+1;i++)
    {
        dis[i] = inf;
        done[i] = false;
    }
    dis[1] = 1;
    priority_queue<node> Q;
    node tmp = node(s,1);
    Q.push(tmp);
    while(!Q.empty())
    {
        node u = Q.top();
        //cout<<dis[u.id]<<endl;
        Q.pop();
        if(done[u.id])
            continue;
        done[u.id] = true;
        for(int i=0;i<G[u.id].size();i++)
        {
            int v=G[u.id][i];
            if(dis[v] > u.dis+1 && !done[v])
            {
                dis[v] = u.dis + 1;
                tmp = node(v,dis[v]);
                Q.push(tmp);
            }
        }
    }
    ans = dis[n];
    if(ans == 0x7f7f7f)
        ans = -1;
}

int main()
{
    cin>>n>>m;
    int cnt = n+1;//记录虚拟结点的编号
    for(int i=1;i<=m;i++) //构建无向图
    {
        int num = 0;
        cin>>num;
        for(int i=1;i<=num;i++)
        {
            int v;
            cin>>v;
            G[cnt].push_back(v);
            G[v].push_back(cnt);
        }
        cnt++;
    }
    Disjktra();
    if(ans != -1)
        cout<<(ans-1)/2<<endl;
    else
        cout<<"-1"<<endl;
    return 0;
}
```

#### 共享单车 (变式Dijkstra最短路) WA代码

```c++
#include<bits/stdc++.h>
using namespace std;
long n,m,k;
long inf = 0x7f7f7f;
struct edge
{
    long from,to,w;
    edge(long a,long b,long c)
    {
        from = a;to = b,w = c;
    }
};
vector<edge> G[100010];
struct node
{
    long id,dis;
    bool isbycicle;//进过该点时是否骑车
    node(long a,long b,bool c=false)
    {
        id = a;dis = b;
        isbycicle = c;
    }
};

bool operator<(node a,node b)
{
    return a.dis > b.dis;
}
long ans;

bool bycicle[100010];
void dijkstra()
{
    long s = 1;
    long dis[100010][2]; //分别表示走过该点或骑单车过该的时间
    for(int i=1;i<=n;i++)
    {
        dis[i][0] = inf;
        dis[i][1] = inf;
    }
    dis[1][bycicle[1]] = 0;
    priority_queue<node> Q;
    Q.push(node(s,0,bycicle[s]));
    while(!Q.empty())
    {
        node u = Q.top();
        //cout<<u.id<<endl;
        Q.pop();
        if(u.id == n)
        {
            ans = u.dis;
            return;
        }
            
        for(int i=0;i<G[u.id].size();i++)
        {
             long t;
            edge y = G[u.id][i];
            if(u.isbycicle)
            {
                t = u.dis + y.w/2;
            }
            else{
                t= u.dis + y.w;
            }
            bool flag = false;
            if(u.isbycicle || bycicle[y.to])
                flag = true;
            if( t < dis[y.to][flag])
            {
                dis[y.to][flag] = t;
                Q.push({y.to,t,flag});
            }
        }
        
    }
}

int main()
{
    cin>>n>>m;
    for(int i=1;i<=m;i++)
        G[i].clear();
    for(int i=1;i<=n;i++)
        bycicle[i] = false;
    for(int i=1;i<=m;i++)
    {
        int u,v,w;
        cin>>u>>v>>w;
        G[u].push_back(edge(u,v,w));
        G[v].push_back(edge(v,u,w));
    }
    cin>>k;
    for(int i=1;i<=k;i++)
    {
        int a;
        cin>>a;
        bycicle[a]=true;
    }
    dijkstra();
    if(ans != -1)
        cout<<ans<<endl;
    else 
        cout<<"-1"<<endl;
    return 0;
}
```

#### 最小生成树

kruskal算法

```c++
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 返回最小的花费代价使得这n户人家连接起来
     * @param n int n户人家的村庄
     * @param m int m条路
     * @param cost intvector<vector<>> 一维3个参数，表示连接1个村庄到另外1个村庄的花费的代价
     * @return int
     */
    static bool cmp(vector<int>& x,vector<int>& y)
    {
        return x[2] < y[2];
    }
    int find(vector<int>& parent,int x)
    {
        if(parent[x] != x)
            parent[x] = find(parent,parent[x]);
        return parent[x];
    }
    int miniSpanningTree(int n, int m, vector<vector<int> >& cost) {
        // write code here
        vector<int> parent(n+1);
        for(int i=0;i<=n;i++)
        {
            parent[i] = i;
        }
        sort(cost.begin(),cost.end(),cmp);
        int res = 0;
        for(int i=0;i<cost.size();i++)
        {
            int x = cost[i][0];
            int y = cost[i][1];
            int w = cost[i][2];
            int fx = find(parent,x);
            int fy = find(parent,y);
            if(fx!=fy)
            {
                res+=w;
                parent[fx] = fy;
            }
        }
        return res;
    }
};
```



### 树

#### 实现二叉树的前中后序遍历

```c++
/**
 * struct TreeNode {
 *	int val;
 *	struct TreeNode *left;
 *	struct TreeNode *right;
 * };
 */

class Solution {
public:
    /**
     * 
     * @param root TreeNode类 the root of binary tree
     * @return int整型vector<vector<>>
     */
    vector<int> pre;
    vector<int> in;
    vector<int> post;
    void preOrder(TreeNode * root){
        pre.push_back(root->val);
        if(root->left)
            preOrder(root->left);
        if(root->right)
            preOrder(root->right);
    }
    void inOrder(TreeNode * root){
        if(root->left)
            inOrder(root->left);
        in.push_back(root->val);
        if(root->right)
            inOrder(root->right);
    }
    void postOrder(TreeNode * root){
        if(root->left)
            postOrder(root->left);
        if(root->right)
            postOrder(root->right);
        post.push_back(root->val);
    }
    vector<vector<int> > threeOrders(TreeNode* root) {
        // write code here
        vector<vector<int>> ans;
        if(root == NULL){
            ans.push_back(pre);
            ans.push_back(in);
            ans.push_back(post);
            return ans;
        }
        preOrder(root);
        inOrder(root);
        postOrder(root);
        ans.push_back(pre);
        ans.push_back(in);
        ans.push_back(post);
        return ans;
    }
};
```

#### 二叉树根节点到叶子节点的所有路径和

```c++
/**
 * struct TreeNode {
 *	int val;
 *	struct TreeNode *left;
 *	struct TreeNode *right;
 * };
 */

class Solution {
public:
    /**
     * 
     * @param root TreeNode类 
     * @return int整型
     */
    int sum = 0;
   vector<int> step;
    void compute(){
        int size = step.size();
        int tempSum = 0;
        vector<int>::iterator it = step.end()-1;
        for(int i=0;i<size;i++){
            tempSum += *it * pow(10,i);
            it--;
        }
        sum += tempSum;
    }
    void dfs(TreeNode * root){
        step.push_back(root->val);
        if(root->left==NULL && root->right==NULL){
            compute();
            step.erase(step.end()-1);
            return;
        }
        if(root->left)
            dfs(root->left);
        if(root->right)
            dfs(root->right);
        step.erase(step.end()-1);
    }
    int sumNumbers(TreeNode* root) {
        if(!root)
            return 0;
        dfs(root);
        return sum;
    }
};
```

时间复杂度为O (N) 空间复杂度为O(1)的标准解法

```c++
/**
 * struct TreeNode {
 *    struct TreeNode *right;
 * };
 */
 
class Solution {
public:
    /**
     *
     * @param root TreeNode类
     * @return int整型
     */
    int sumNumbers(TreeNode* root) {
        // write code here
        if(!root)//特殊情况
            return 0;
        int sum = 0;
        return preorder(root, sum);
    }
    
    int preorder(TreeNode* root, int sum){
        if(root == NULL)
            return 0;
        sum = sum * 10 + root->val;//一层一层进行遍历
        if(!root->left && !root->right)//没有子结点
            return sum;
        return preorder(root->left, sum) + preorder(root->right, sum);
    }
};
```

#### 输出二叉树的右视图

```c++
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     * 求二叉树的右视图
     * @param xianxu int整型vector 先序遍历
     * @param zhongxu int整型vector 中序遍历
     * @return int整型vector
     */
    unordered_map<int, int> index;
    TreeNode * buildTree(vector<int>& xianxu,int l1,int r1,vector<int>zhongxu,int l2,int r2)
    {
        if(l1>r1 || l2>r2)
            return NULL;
        int xianxu_root=l1;//前序遍历中的第一个结点就是根节点
        int zhongxu_root=index[xianxu[xianxu_root]];//中序遍历中定位根节点
        TreeNode * root=new TreeNode(xianxu[xianxu_root]);
        int leftsize=zhongxu_root-l2;
        root->left=buildTree(xianxu,l1+1,l1+leftsize,zhongxu,l2,zhongxu_root-1);
        root->right=buildTree(xianxu,l1+leftsize+1,r1,zhongxu,zhongxu_root+1,r2);
        return root;
    }
    
    vector<int> rightSideView(TreeNode * root){
        vector<int> res;
        queue<TreeNode*> Q;
        Q.push(root);
        while(!Q.empty())
        {
            int size = Q.size();
            //队列中的大小即是这一层的节点数
            while(size--)
            {
                TreeNode * temp = Q.front();
                Q.pop();
                if(temp->left)
                    Q.push(temp->left);
                if(temp->right)
                    Q.push(temp->right);
                if(size==0)//最右元素
                    res.push_back(temp->val);
            }
        }
        return res;
    }
    
    vector<int> solve(vector<int>& xianxu, vector<int>& zhongxu) {
        // write code here
        vector<int> res;
        if(xianxu.size()==0)
            return res;
        for(int i=0;i<xianxu.size();i++){
            index[zhongxu[i]] = i;
        }
        TreeNode * root=buildTree(xianxu,0,xianxu.size()-1,zhongxu,0,zhongxu.size()-1);
        return rightSideView(root);
    }
};
```

#### 二叉树第k个节点

```c++
/**
 * struct TreeNode {
 *	int val;
 *	struct TreeNode *left;
 *	struct TreeNode *right;
 *	TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 * };
 */
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param proot TreeNode类 
     * @param k int整型 
     * @return int整型
     */
    vector<int> in;
    void inOrder(TreeNode * root)
    {
        if(root->left)
            inOrder(root->left);
        in.push_back(root->val);
        if(root->right)
            inOrder(root->right);
    }
    int KthNode(TreeNode* proot, int k) {
        // write code here
        if(proot == NULL) return -1;
        inOrder(proot);
        if(k>in.size() || k<=0)
            return -1;
        return in[k-1];
    }
};
```

#### 判断t1树中是否含有和t2树一样的子树(WA代码)

```c++
/**
 * struct TreeNode {
 *	int val;
 *	struct TreeNode *left;
 *	struct TreeNode *right;
 * };
 */

class Solution {
public:
    /**
     * 
     * @param root1 TreeNode类 
     * @param root2 TreeNode类 
     * @return bool布尔型
     */
    bool flag=false;
    bool check(TreeNode* root1, TreeNode* root2){
        if(root1==NULL && root2==NULL)
            return false;
        if(root1->left==NULL && root2->left==NULL && root1->right==NULL && root2->right==NULL)
        {    
            flag=flag||(root1->val==root2->val);
            return root1->val==root2->val;
        }
        bool Left=false;
        bool Right=false;
        if(root1->left && root2->left)
            Left = isContains(root1->left, root2->left);
        if(root1->left==NULL && root2->left==NULL)
            Left=true;
        if(root1->right && root2->right)
           Right = isContains(root1->right,root2->right);
        if(root1->right==NULL && root2->right==NULL)
            Right=true;
        flag=(flag||(Left && Right));
        return Left && Right;
    }    
    bool isContains(TreeNode* root1, TreeNode* root2) {
        // write code here
        bool a=check(root1,root2);
        return flag;
    }
};
```

#### 判断t1树中是否含有和t2树一样的子树(正解)

```c++
/**
 * struct TreeNode {
 *	int val;
 *	struct TreeNode *left;
 *	struct TreeNode *right;
 * };
 */

class Solution {
public:
    /**
     *
     * @param root1 TreeNode类
     * @param root2 TreeNode类
     * @return bool布尔型
     */
    bool isContains(TreeNode* root1, TreeNode* root2) {
        // write code here
        if (root2 == NULL) return true;
        if (root1 == NULL) return false;
        return (isSubTree(root1, root2) || isContains(root1->left, root2) || isContains(root1->right, root2));
    }
 
    bool isSubTree(TreeNode* root1, TreeNode* root2) {
        if (root1 == NULL && root2 == NULL)
            return true;
        if (root1 == NULL || root2 == NULL || (root1->val != root2->val))
            return false;
        return (isSubTree(root1->left, root2->left) && isSubTree(root1->right, root2->right));
    }
 
};
```

#### 信用卡推荐用户列表（二叉树的深度）

Java语言

```java
import java.util.Scanner;
import java.util.*;
import java.math.*;
public class Main
{
    static int [][] map = new int[27][3];
    static int [] ans = new int[27];
    static int n,m;
    public static void main(String arg[])
    {
         Scanner in = new Scanner(System.in);
         m=in.nextInt(); n = in.nextInt();
        //System.out.println(m);
         for(int i=0;i<26;i++)
             for(int j=0;j<2;j++)
                 map[i][j] = -1;
         for(int i=0;i<m;i++)
         {
             char u,v1,v2;
             boolean hasSecond = true;
             u = in.next().charAt(0);
             v1 = in.next().charAt(0);
             v2 = in.next().charAt(0);
             if(v2 == '*')
                 hasSecond = false;
             int U,V1,V2;
             U = (int)(u-'A');
             V1 = (int)(v1-'A');
             map[U][0] = V1;
             if(hasSecond){
                 V2 = (int)(v2-'A');
                 map[U][1] = V2;
             }
         }
        int deep = dfs(0);
        int cnt = 0;
        for(int i=0;i<26;i++)
        {
            if(ans[i] == 1)
                cnt++;
        }
        if(cnt == 0){
            System.out.println("None");
            return;
        }
        for(int i=0;i<26;i++)
        {
            if(ans[i] == 1){
                char a =(char)( 'A' + i);
                System.out.print(a+" ");
             }
        }
        System.out.println();
    }
    private static int dfs(int index)
    {
        int L = map[index][0];
        int R = map[index][1];
        if(n == 0)
            ans[index] = 1;
        if(L == -1 && R == -1)
            return 1;
        int deep = 0;
        if(L != -1)
            deep = dfs(L);
        if(R != -1)
            deep = deep + dfs(R);
        if(deep >= n)
            ans[index] = 1;
        return deep+1;
    }
}

```

### 并查集

#### 集合合并

```c++
#include<bits/stdc++.h>
using namespace std;

unordered_map<int,int> parents;
unordered_map<int,int> cnt;  //记录每个集合的元素数量

int Find(int x)
{    //路径压缩
    if(parents[x] != x)
    {
        parents[x] = Find(parents[x]);
    }
    return   parents[x];
}

void Union(int a,int b)
{   //按秩归并
    int pa = Find(a);int pb = Find(b);
    if(pa == pb)  //这里必须要 否则会导致相同的集合元素数量翻倍
        return;
        if(cnt[pa] >= cnt[pb])
    {
        parents[pb] = parents[pa];
        cnt[pa]+= cnt[pb]; 
        cnt[pb] = 0;
    }
    else{
        parents[pa] = parents[pb];
        cnt[pb] += cnt[pa];
        cnt[pa] = 0;
    }
}

int main()
{
    int N;
    cin>>N;
    for(int i=0;i<N;i++)
    {
        int a,b;
        cin>>a;
        if(!parents.count(a))
        {
            parents[a] = a;
            cnt[a] = 1;
        }
        while(getchar()!='\n')
        {
            cin>>b;
            if(!parents.count(b))
            {
                parents[b] = Find(a);
                cnt[Find(a)]++;
            }
            else
            {
                Union(a, b);
            }
        }
    }
    
    int sum=0,maxn = 0;
    for(auto v:cnt)
    {
        if(v.second != 0)
        {
            sum++;
            maxn = max(maxn,v.second);
        }
    }
    cout<<sum<<endl<<maxn<<endl;
    return 0;
}
```

